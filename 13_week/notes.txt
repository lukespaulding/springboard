Exercise #1:

  Expectations: 

    I think that it will start with printing the As, and then devolve into printing a,b,c in arbitrary ways. 
    We cannot reliably predict how the system will choose to give threads priority in this situation. 

  Results:
    
    My guess seems to be correct! One interesting thing that I noticed however was that I did have cases where it would finish with all 100 letts As before it would move on to "randomly" deciding beteween Bs and Cs. 

    When execution reaches Line A, all three threads are running. 

  After commenting out the join, we get a fatal error, and a core dump. This creates a file named core.1234, which are dumps of memory created by errors. This error was caused by not joining a thread. 

  Asssuming that we do not care about the exact ordering of the letters, this code looks fine to me!. I am not entirely sure if it is *actually* printing exactly 100 lettters each, but we can expect that to work just fine. The lines are printed in the correct place, and all seems to be functioning at the level we would expect. 


Exercise #2:

  Counter and counter_mutex are being passed by reference to the threads so that they can update a shared variable, instead of updating their own instances of counter. This is one of the uses for reference that I have missed the most working in Java- it is very helpful for threads. 

  Expectatiom: 

    I would anticipate for this to take about a second to run. - But I do not think that it will pass because the threads will be fighting over the variable and cause issues. It is not locked or thread safe. 
  
  Result:

    I was correct in my guess! It took around a second to run, but failed because the count did not hit 3000. 

  With the addition of a lock_guard in the for loop, the increment operation now works without a hitch! The time did not increase by a noticeable amount- it still takes around a second for it to run. However, the tests now pass. 

  With only the lock_guard and increment operations inside the local scope block, the code runs in .003s. I do want to note however that I may have misunderstood this question. Removing one second of sleep time does remove a second of time to execute the program, but I am not sure that was the objective here! Assuming it was however, I would say that code that requires so much time to run should be outside of critical sections so that they can perform their tasks without waiting forever. 
